# Feature Specification: 微前端架构优化 - 统一配置管理和路由同步改进

**Feature Branch**: `002-`
**Created**: 2025-10-09
**Status**: Draft
**Input**: User description: "根据上面的建议来处理"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 统一配置管理中心 (Priority: P1)

作为一个开发工程师,我需要在一个集中的配置文件中管理所有微应用的信息(名称、端口、URL等),这样当我需要修改某个微应用的配置时,只需要在一个地方修改,避免在多个文件中重复修改导致的配置不一致问题。

**Why this priority**: 这是架构优化的基础,解决当前配置分散在多处(wujie-config.js, MicroAppContainer.vue)导致的维护困难和配置冗余问题。没有统一配置管理,后续的环境切换和扩展都会受到影响。

**Independent Test**: 可以通过修改配置文件中的单个微应用端口号,验证所有引用该应用的地方都自动使用新端口,无需手动修改多处代码。

**Acceptance Scenarios**:

1. **Given** 系统存在6个微应用配置分散在多个文件中, **When** 创建统一配置文件并迁移所有配置, **Then** 所有微应用的名称、端口、URL等信息只在一个配置文件中定义
2. **Given** 配置文件已创建, **When** 修改某个微应用的端口号, **Then** 主应用和相关组件自动读取新端口号,无需修改多处代码
3. **Given** 需要添加新的微应用, **When** 在配置文件中添加新应用配置, **Then** 系统自动识别并加载新应用,无需修改业务代码
4. **Given** 开发环境需要使用localhost, **When** 切换到生产环境, **Then** 系统根据环境变量自动使用对应的URL配置

---

### User Story 2 - 标准化路由同步协议 (Priority: P1)

作为一个前端架构师,我需要一套标准化的路由同步机制,使主应用和微应用之间的路由同步变得可靠和可预测,消除当前使用延时(setTimeout)和标志位(lastSyncedPath)等不稳定的hack代码。

**Why this priority**: 当前路由同步机制是导致"空白页面"和"路由不同步"等bug的根源。标准化路由协议可以消除90%以上的路由相关问题,直接影响用户体验和系统稳定性。

**Independent Test**: 可以通过在浏览器地址栏直接输入微应用的深层路由(如/system/users),验证页面立即显示正确内容,无延迟、无空白页。

**Acceptance Scenarios**:

1. **Given** 用户在主应用导航到微应用的某个页面, **When** 路由变化发生, **Then** 微应用立即接收到路由事件并更新页面,无需延时等待
2. **Given** 微应用内部路由发生变化, **When** 用户点击子应用菜单, **Then** 主应用接收到路由更新事件并同步地址栏URL
3. **Given** 用户直接在地址栏输入微应用深层路由, **When** 页面加载, **Then** 微应用正确渲染对应页面,无空白页或404错误
4. **Given** 多个微应用快速切换, **When** 用户连续点击不同应用菜单, **Then** 路由同步准确无误,无串台或延迟问题
5. **Given** 路由同步失败(网络问题或应用未加载), **When** 系统检测到同步失败, **Then** 记录错误日志并显示友好提示,不影响其他功能

---

### User Story 3 - 应用间共享状态管理 (Priority: P2)

作为一个产品经理,我需要在不同微应用之间共享用户信息、通知消息等状态,这样用户在某个微应用中执行的操作(如修改个人信息)能够立即在其他微应用中生效,无需刷新页面。

**Why this priority**: 当前只支持主应用单向传递状态给微应用,缺少微应用间的状态共享能力,导致用户体验不连贯。虽然不是核心功能,但对提升用户体验有重要价值。

**Independent Test**: 可以通过在系统管理应用中修改用户头像,验证仪表盘应用中的用户头像立即更新,无需刷新页面。

**Acceptance Scenarios**:

1. **Given** 用户在系统管理应用修改个人信息, **When** 修改成功, **Then** 所有其他微应用中显示的用户信息实时更新
2. **Given** 主应用接收到新通知, **When** 通知状态发生变化, **Then** 所有微应用的通知图标同步更新未读数量
3. **Given** 用户的权限发生变化, **When** 管理员修改用户权限, **Then** 用户在所有微应用中的可见菜单和操作按钮立即更新
4. **Given** 某个微应用发布全局状态更新, **When** 其他应用订阅该状态, **Then** 订阅者收到状态变化通知并触发回调
5. **Given** 微应用被卸载, **When** 应用销毁, **Then** 自动清理该应用的状态订阅,避免内存泄漏

---

### User Story 4 - 错误边界和降级策略 (Priority: P2)

作为一个运维工程师,我需要系统在某个微应用加载失败时能够优雅降级,显示友好的错误提示和重试按钮,而不是整个页面白屏,同时错误信息能够自动上报到监控系统。

**Why this priority**: 提升系统健壮性和用户体验,避免单个微应用的故障影响整个系统。虽然不是日常开发的核心需求,但对生产环境的稳定性至关重要。

**Independent Test**: 可以通过故意关闭某个微应用的服务,验证主应用显示错误提示页面,提供重试按钮,其他应用正常运行。

**Acceptance Scenarios**:

1. **Given** 某个微应用服务不可用, **When** 用户访问该应用, **Then** 显示友好的错误提示页面,包含重试按钮和返回首页链接
2. **Given** 微应用加载超时(超过5秒), **When** 加载时间过长, **Then** 显示加载超时提示,提供刷新和返回选项
3. **Given** 微应用运行时发生JavaScript错误, **When** 错误被捕获, **Then** 错误边界拦截错误,显示降级UI,不影响主应用和其他微应用
4. **Given** 微应用加载失败, **When** 错误发生, **Then** 错误详情自动上报到监控系统,包含应用名称、错误堆栈、用户信息等
5. **Given** 用户点击重试按钮, **When** 执行重试, **Then** 清除错误状态并重新加载微应用

---

### User Story 5 - 共享组件库构建优化 (Priority: P3)

作为一个前端开发工程师,我需要共享组件库提供构建后的产物而不是源码,这样微应用在开发和构建时可以直接使用稳定的编译后代码,加快构建速度并减少兼容性问题。

**Why this priority**: 优化开发体验和构建性能,但不影响核心功能。可以在前期功能稳定后再进行优化。

**Independent Test**: 可以通过对比构建前后的微应用构建时间,验证构建速度提升,以及运行时无编译错误。

**Acceptance Scenarios**:

1. **Given** 共享组件库完成构建配置, **When** 执行构建命令, **Then** 生成dist目录包含编译后的JS、类型定义和样式文件
2. **Given** 微应用导入共享组件, **When** 执行构建, **Then** 构建时间相比使用源码减少30%以上
3. **Given** 共享组件库更新版本, **When** 微应用升级依赖, **Then** 通过语义化版本管理,避免意外的破坏性变更
4. **Given** 共享组件库支持Tree Shaking, **When** 微应用只导入部分组件, **Then** 打包后的bundle只包含实际使用的代码

---

### Edge Cases

- **配置文件损坏或格式错误**: 系统应验证配置文件格式,加载失败时使用默认配置并显示警告
- **微应用URL不可访问**: 应在开发环境提供清晰的错误提示,告知开发者哪个应用服务未启动
- **路由事件总线(bus)不可用**: 降级到静态路由模式,记录警告日志但不阻塞应用运行
- **状态同步冲突**: 当多个微应用同时更新同一状态时,应采用"最后写入胜出"策略并记录冲突日志
- **网络延迟导致状态更新不同步**: 设置合理的超时时间(如3秒),超时后显示加载状态并允许用户刷新
- **循环依赖导致的无限路由同步**: 通过路由版本号和防抖机制,检测并阻止循环同步
- **微应用版本不兼容**: 在配置中声明版本要求,主应用加载时验证兼容性,不兼容时拒绝加载并提示升级

## Requirements *(mandatory)*

### Functional Requirements

#### 统一配置管理

- **FR-001**: 系统必须提供集中式配置文件,定义所有微应用的名称、端口、基础路径和URL映射
- **FR-002**: 配置文件必须支持多环境(开发、测试、生产)的URL配置,根据环境变量自动选择
- **FR-003**: 系统必须提供配置读取函数,供主应用和微应用统一使用,避免直接硬编码
- **FR-004**: 配置文件必须支持扩展字段,如微应用的元数据(版本号、描述、维护者等)
- **FR-005**: 当配置文件加载失败或格式错误时,系统必须降级到内置的默认配置,并记录警告日志

#### 路由同步机制

- **FR-006**: 系统必须提供标准化的路由同步类,封装主应用到微应用的路由通知逻辑
- **FR-007**: 路由同步必须使用事件总线的标准协议,包含目标应用名、路径、完整路径和元数据
- **FR-008**: 微应用必须能够监听路由同步事件,接收路径并更新内部路由,无需延时等待
- **FR-009**: 微应用必须能够上报路由变化事件给主应用,包含源应用名、路径和页面标题
- **FR-010**: 路由同步必须支持防抖机制,避免短时间内重复同步相同路径
- **FR-011**: 路由同步失败时(如微应用未加载或事件总线不可用),必须记录详细错误日志,包含应用名和路径

#### 共享状态管理

- **FR-012**: 系统必须提供共享状态管理器,支持发布-订阅模式的状态共享
- **FR-013**: 状态管理器必须支持状态的设置(setState)、获取(getState)和订阅(subscribe)操作
- **FR-014**: 当状态更新时,系统必须通过事件总线广播状态变化,通知所有订阅者
- **FR-015**: 微应用销毁时,系统必须自动清理该应用的状态订阅,避免内存泄漏
- **FR-016**: 状态管理器必须支持命名空间隔离,避免不同微应用的状态键冲突

#### 错误处理和降级

- **FR-017**: 主应用必须为每个微应用容器提供错误边界组件,捕获加载和运行时错误
- **FR-018**: 当微应用加载失败时,系统必须显示友好的错误页面,包含错误描述和重试按钮
- **FR-019**: 错误边界必须隔离错误,确保单个微应用的故障不影响主应用和其他微应用
- **FR-020**: 系统必须提供错误上报函数,将错误详情(应用名、错误类型、堆栈、时间戳)发送到监控服务
- **FR-021**: 微应用加载超时(默认5秒)时,系统必须显示超时提示并提供刷新选项

#### 共享组件库优化

- **FR-022**: 共享组件库必须提供构建脚本,生成编译后的JavaScript和类型定义文件
- **FR-023**: 构建产物必须支持ES Module格式,确保Tree Shaking优化生效
- **FR-024**: package.json的exports字段必须指向构建后的文件路径,而非源码路径
- **FR-025**: 共享组件库必须遵循语义化版本规范,主版本号变更表示破坏性变更

### Key Entities

- **MicroAppConfig**: 微应用配置实体,包含名称(name)、端口(port)、基础路径(basePath)、环境URL映射(entry)、元数据(metadata)
- **RouteEvent**: 路由事件实体,包含事件类型(type: 'sync'|'report')、源应用(sourceApp)、目标应用(targetApp)、路径(path)、完整路径(fullPath)、元数据(meta)
- **SharedState**: 共享状态实体,包含状态键(key)、状态值(value)、命名空间(namespace)、时间戳(timestamp)
- **ErrorInfo**: 错误信息实体,包含应用名(appName)、错误类型(errorType)、错误消息(message)、堆栈(stack)、发生时间(timestamp)、用户信息(userInfo)

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 开发者修改微应用配置(如端口号)时,只需修改一个配置文件,所有引用该配置的代码自动生效,配置修改点从当前的3-5处减少到1处
- **SC-002**: 用户直接在地址栏输入微应用深层路由时,页面在500毫秒内完成渲染,无空白页或闪烁
- **SC-003**: 路由同步相关的代码复杂度降低60%以上,移除所有setTimeout和标志位等不稳定代码
- **SC-004**: 微应用在系统管理中修改个人信息后,其他微应用中的用户信息在1秒内自动更新,无需刷新页面
- **SC-005**: 当某个微应用加载失败时,用户在3秒内看到友好的错误提示和重试按钮,其他微应用正常运行不受影响
- **SC-006**: 错误发生时,90%以上的错误信息在5秒内成功上报到监控系统,包含完整的上下文信息
- **SC-007**: 微应用构建时间相比使用共享组件源码减少30%以上
- **SC-008**: 新增微应用时,开发者只需在配置文件添加配置即可完成集成,无需修改业务代码,集成时间从2小时减少到30分钟以内

## Assumptions

- 系统已经使用Wujie微前端框架,本次优化基于Wujie的事件总线机制
- 微应用已经实现基本的路由功能,使用Vue Router或类似路由库
- 开发环境使用Node.js 16+和pnpm作为包管理器
- 监控系统已经存在(或可以使用console.log作为临时方案),用于接收错误上报
- 配置文件格式采用JavaScript或JSON,存储在项目根目录或config目录
- 状态同步采用"最后写入胜出"策略,无需复杂的冲突解决机制
- 微应用版本兼容性通过手动测试验证,暂不实现自动化版本检测(可在后续迭代中添加)
- 共享组件库的构建工具使用Vite,与项目现有技术栈一致

## Dependencies

- Wujie微前端框架(wujie-vue3)提供的事件总线(bus)
- Vue Router 4用于路由管理
- Vite用于共享组件库的构建
- 现有的pnpm workspace配置
- localStorage用于本地配置缓存(可选)

## Out of Scope

- 微应用的自动版本检测和兼容性验证(保留为未来功能)
- 复杂的状态冲突解决机制(如CRDT或OT算法)
- 分布式监控系统的完整实现(只提供上报接口,具体监控平台由基础设施团队负责)
- 微应用的热更新和动态加载(保持现有机制)
- 跨浏览器Tab页的状态同步(只支持同一Tab页内的微应用间同步)
- 服务端渲染(SSR)场景的支持
- 微应用的权限和安全沙箱增强(保持Wujie默认隔离机制)
